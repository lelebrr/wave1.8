/*!
 * Minimal Chart.js subset – enough for a single animated line chart.
 * This is NOT the full official build, apenas o necessário para o dashboard.
 * API usada: new Chart(ctx, { type: 'line', data, options })
 */
(function (global) {
  "use strict";

  function merge(target, src) {
    for (var k in src) {
      if (Object.prototype.hasOwnProperty.call(src, k)) {
        if (src[k] && typeof src[k] === "object" && !Array.isArray(src[k])) {
          if (!target[k]) target[k] = {};
          merge(target[k], src[k]);
        } else {
          target[k] = src[k];
        }
      }
    }
    return target;
  }

  function LineController(chart, cfg) {
    this.chart = chart;
    this.ctx = chart.ctx;
    this.data = cfg.data;
    this.options = cfg.options || {};
  }

  LineController.prototype._getScaleRange = function () {
    var y = this.chart.scales.y;
    if (!y) {
      var min = 0, max = 0;
      this.data.datasets[0].data.forEach(function (v) {
        if (typeof v === "number") {
          if (v < min) min = v;
          if (v > max) max = v;
        }
      });
      return { min: min, max: max || 1 };
    }
    return { min: y.min, max: y.max };
  };

  LineController.prototype.draw = function () {
    var ctx = this.ctx;
    var data = this.data;
    var labels = data.labels || [];
    if (!labels.length) return;
    var dataset = data.datasets[0] || {};
    var vals = dataset.data || [];
    if (!vals.length) return;

    var width = this.chart.width;
    var height = this.chart.height;
    var paddingLeft = 28;
    var paddingRight = 6;
    var paddingTop = 6;
    var paddingBottom = 18;

    ctx.clearRect(0, 0, width, height);

    var range = this._getScaleRange();
    var ymin = typeof this.options.scales?.y?.min === "number"
      ? this.options.scales.y.min
      : range.min;
    var ymax = typeof this.options.scales?.y?.max === "number"
      ? this.options.scales.y.max
      : range.max;

    if (ymax === ymin) ymax = ymin + 1;

    function xFor(i) {
      if (vals.length === 1) return paddingLeft + (width - paddingLeft - paddingRight) / 2;
      var t = i / (vals.length - 1);
      return paddingLeft + t * (width - paddingLeft - paddingRight);
    }

    function yFor(v) {
      var t = (v - ymin) / (ymax - ymin);
      t = Math.max(0, Math.min(1, t));
      return height - paddingBottom - t * (height - paddingTop - paddingBottom);
    }

    // Grid horizontal
    ctx.save();
    ctx.strokeStyle = "rgba(31,41,55,0.7)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    var steps = (this.options.scales && this.options.scales.y && this.options.scales.y.ticks && this.options.scales.y.ticks.stepSize) || 1;
    for (var yVal = ymin; yVal <= ymax + 0.01; yVal += steps) {
      var yy = yFor(yVal);
      ctx.moveTo(paddingLeft, yy);
      ctx.lineTo(width - paddingRight, yy);
    }
    ctx.stroke();
    ctx.restore();

    // Eixo X labels simplificados (hora)
    if (this.options.scales && this.options.scales.x) {
      ctx.save();
      ctx.fillStyle = "#9ca3af";
      ctx.font = "9px system-ui";
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      var step = Math.max(1, Math.floor(labels.length / 5));
      for (var i = 0; i < labels.length; i += step) {
        var x = xFor(i);
        ctx.fillText(labels[i], x, height - paddingBottom + 2);
      }
      ctx.restore();
    }

    // Eixo Y labels
    if (this.options.scales && this.options.scales.y) {
      ctx.save();
      ctx.fillStyle = "#9ca3af";
      ctx.font = "9px system-ui";
      ctx.textAlign = "right";
      ctx.textBaseline = "middle";
      for (var yVal2 = ymin; yVal2 <= ymax + 0.01; yVal2 += steps) {
        var yy2 = yFor(yVal2);
        ctx.fillText(String(Math.round(yVal2)), paddingLeft - 4, yy2);
      }
      ctx.restore();
    }

    // Área preenchida
    ctx.save();
    var bg = dataset.backgroundColor || "rgba(34,211,238,0.25)";
    var border = dataset.borderColor || "#22d3ee";
    ctx.beginPath();
    for (var j = 0; j < vals.length; j++) {
      var v = Number(vals[j]) || 0;
      var x = xFor(j);
      var y = yFor(v);
      if (j === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    var lastX = xFor(vals.length - 1);
    var baseY = yFor(ymin);
    ctx.lineTo(lastX, baseY);
    ctx.lineTo(xFor(0), baseY);
    ctx.closePath();
    ctx.fillStyle = bg;
    ctx.fill();
    ctx.restore();

    // Linha
    ctx.save();
    ctx.beginPath();
    for (var k = 0; k < vals.length; k++) {
      var vv = Number(vals[k]) || 0;
      var xx = xFor(k);
      var yy3 = yFor(vv);
      if (k === 0) ctx.moveTo(xx, yy3);
      else ctx.lineTo(xx, yy3);
    }
    ctx.strokeStyle = border;
    ctx.lineWidth = dataset.borderWidth || 2;
    ctx.lineJoin = "round";
    ctx.lineCap = "round";
    ctx.stroke();
    ctx.restore();
  };

  function Chart(ctx, cfg) {
    this.ctx = ctx;
    this.data = cfg.data || {};
    this.options = merge(
      {
        animation: false,
        responsive: true,
        maintainAspectRatio: false,
      },
      cfg.options || {}
    );
    this.width = ctx.canvas.width;
    this.height = ctx.canvas.height;

    if (cfg.type === "line") {
      this.controller = new LineController(this, { data: this.data, options: this.options });
    } else {
      throw new Error("Minimal Chart.js build: only 'line' charts are supported.");
    }

    this.update();
  }

  Chart.prototype.update = function () {
    if (this.controller && this.controller.draw) {
      this.width = this.ctx.canvas.clientWidth || this.ctx.canvas.width;
      this.height = this.ctx.canvas.clientHeight || this.ctx.canvas.height;
      if (this.ctx.canvas.width !== this.width) this.ctx.canvas.width = this.width;
      if (this.ctx.canvas.height !== this.height) this.ctx.canvas.height = this.height;
      this.controller.draw();
    }
  };

  Chart.controllers = {};
  Chart.register = function () { /* no-op in minimal build */ };

  global.Chart = Chart;
})(typeof window !== "undefined" ? window : this);